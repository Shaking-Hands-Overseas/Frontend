import { from } from 'rxjs';
import { filter, map, pairwise, scan, startWith } from 'rxjs/operators';
import { keepUnstableUntilFirst, observeInsideAngular } from '@angular/fire';
import { docChanges, sortedChanges } from './changes';
import { AngularFirestoreDocument } from '../document/document';
import { fromCollectionRef } from '../observable/fromRef';
export function validateEventsArray(events) {
    if (!events || events.length === 0) {
        events = ['added', 'removed', 'modified'];
    }
    return events;
}
/**
 * AngularFirestoreCollection service
 *
 * This class creates a reference to a Firestore Collection. A reference and a query are provided in
 * in the constructor. The query can be the unqueried reference if no query is desired.The class
 * is generic which gives you type safety for data update methods and data streaming.
 *
 * This class uses Symbol.observable to transform into Observable using Observable.from().
 *
 * This class is rarely used directly and should be created from the AngularFirestore service.
 *
 * Example:
 *
 * const collectionRef = firebase.firestore.collection('stocks');
 * const query = collectionRef.where('price', '>', '0.01');
 * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);
 *
 * // NOTE!: the updates are performed on the reference not the query
 * await fakeStock.add({ name: 'FAKE', price: 0.01 });
 *
 * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.
 * fakeStock.valueChanges().subscribe(value => console.log(value));
 */
export class AngularFirestoreCollection {
    /**
     * The constructor takes in a CollectionReference and Query to provide wrapper methods
     * for data operations and data streaming.
     *
     * Note: Data operation methods are done on the reference not the query. This means
     * when you update data it is not updating data to the window of your query unless
     * the data fits the criteria of the query. See the AssociatedRefence type for details
     * on this implication.
     */
    constructor(ref, query, afs) {
        this.ref = ref;
        this.query = query;
        this.afs = afs;
    }
    /**
     * Listen to the latest change in the stream. This method returns changes
     * as they occur and they are not sorted by query order. This allows you to construct
     * your own data structure.
     */
    stateChanges(events) {
        let source = docChanges(this.query, this.afs.schedulers.outsideAngular);
        if (events && events.length > 0) {
            source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));
        }
        return source.pipe(
        // We want to filter out empty arrays, but always emit at first, so the developer knows
        // that the collection has been resolve; even if it's empty
        startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([prior, current]) => current), keepUnstableUntilFirst);
    }
    /**
     * Create a stream of changes as they occur it time. This method is similar to stateChanges()
     * but it collects each event in an array over time.
     */
    auditTrail(events) {
        return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));
    }
    /**
     * Create a stream of synchronized changes. This method keeps the local array in sorted
     * query order.
     */
    snapshotChanges(events) {
        const validatedEvents = validateEventsArray(events);
        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);
        return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);
    }
    valueChanges(options = {}) {
        return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular)
            .pipe(map(actions => actions.payload.docs.map(a => {
            if (options.idField) {
                return Object.assign(Object.assign({}, a.data()), { [options.idField]: a.id });
            }
            else {
                return a.data();
            }
        })), keepUnstableUntilFirst);
    }
    /**
     * Retrieve the results of the query once.
     */
    get(options) {
        return from(this.query.get(options)).pipe(observeInsideAngular);
    }
    /**
     * Add data to a collection reference.
     *
     * Note: Data operation methods are done on the reference not the query. This means
     * when you update data it is not updating data to the window of your query unless
     * the data fits the criteria of the query.
     */
    add(data) {
        return this.ref.add(data);
    }
    /**
     * Create a reference to a single document in a collection.
     */
    doc(path) {
        // TODO is there a better way to solve this type issue
        return new AngularFirestoreDocument(this.ref.doc(path), this.afs);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9jb21wYXQvZmlyZXN0b3JlL2NvbGxlY3Rpb24vY29sbGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLG9CQUFvQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzdFLE9BQU8sRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3RELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRzFELE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxNQUE2QjtJQUMvRCxJQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2xDLE1BQU0sR0FBRyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7S0FDM0M7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkc7QUFDSCxNQUFNLE9BQU8sMEJBQTBCO0lBQ3JDOzs7Ozs7OztPQVFHO0lBQ0gsWUFDa0IsR0FBMkIsRUFDMUIsS0FBZSxFQUNmLEdBQXFCO1FBRnRCLFFBQUcsR0FBSCxHQUFHLENBQXdCO1FBQzFCLFVBQUssR0FBTCxLQUFLLENBQVU7UUFDZixRQUFHLEdBQUgsR0FBRyxDQUFrQjtJQUFJLENBQUM7SUFFN0M7Ozs7T0FJRztJQUNILFlBQVksQ0FBQyxNQUE2QjtRQUN4QyxJQUFJ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LEdBQUcsQ0FBUyxJQUFhO1FBQ3ZCLHNEQUFzRDtRQUN0RCxPQUFPLElBQUksd0JBQXdCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFRLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzNFLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyb20sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCBwYWlyd2lzZSwgc2Nhbiwgc3RhcnRXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlL2NvbXBhdC9hcHAnO1xuaW1wb3J0IHsga2VlcFVuc3RhYmxlVW50aWxGaXJzdCwgb2JzZXJ2ZUluc2lkZUFuZ3VsYXIgfSBmcm9tICdAYW5ndWxhci9maXJlJztcblxuaW1wb3J0IHsgQ29sbGVjdGlvblJlZmVyZW5jZSwgRG9jdW1lbnRDaGFuZ2VBY3Rpb24sIERvY3VtZW50Q2hhbmdlVHlwZSwgRG9jdW1lbnREYXRhLCBEb2N1bWVudFJlZmVyZW5jZSwgUXVlcnkgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGRvY0NoYW5nZXMsIHNvcnRlZENoYW5nZXMgfSBmcm9tICcuL2NoYW5nZXMnO1xuaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZURvY3VtZW50IH0gZnJvbSAnLi4vZG9jdW1lbnQvZG9jdW1lbnQnO1xuaW1wb3J0IHsgZnJvbUNvbGxlY3Rpb25SZWYgfSBmcm9tICcuLi9vYnNlcnZhYmxlL2Zyb21SZWYnO1xuaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZSB9IGZyb20gJy4uL2ZpcmVzdG9yZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUV2ZW50c0FycmF5KGV2ZW50cz86IERvY3VtZW50Q2hhbmdlVHlwZVtdKSB7XG4gIGlmICghZXZlbnRzIHx8IGV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBldmVudHMgPSBbJ2FkZGVkJywgJ3JlbW92ZWQnLCAnbW9kaWZpZWQnXTtcbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG4vKipcbiAqIEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uIHNlcnZpY2VcbiAqXG4gKiBUaGlzIGNsYXNzIGNyZWF0ZXMgYSByZWZlcmVuY2UgdG8gYSBGaXJlc3RvcmUgQ29sbGVjdGlvbi4gQSByZWZlcmVuY2UgYW5kIGEgcXVlcnkgYXJlIHByb3ZpZGVkIGluXG4gKiBpbiB0aGUgY29uc3RydWN0b3IuIFRoZSBxdWVyeSBjYW4gYmUgdGhlIHVucXVlcmllZCByZWZlcmVuY2UgaWYgbm8gcXVlcnkgaXMgZGVzaXJlZC5UaGUgY2xhc3NcbiAqIGlzIGdlbmVyaWMgd2hpY2ggZ2l2ZXMgeW91IHR5cGUgc2FmZXR5IGZvciBkYXRhIHVwZGF0ZSBtZXRob2RzIGFuZCBkYXRhIHN0cmVhbWluZy5cbiAqXG4gKiBUaGlzIGNsYXNzIHVzZXMgU3ltYm9sLm9ic2VydmFibGUgdG8gdHJhbnNmb3JtIGludG8gT2JzZXJ2YWJsZSB1c2luZyBPYnNlcnZhYmxlLmZyb20oKS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIHJhcmVseSB1c2VkIGRpcmVjdGx5IGFuZCBzaG91bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBBbmd1bGFyRmlyZXN0b3JlIHNlcnZpY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBjb25zdCBjb2xsZWN0aW9uUmVmID0gZmlyZWJhc2UuZmlyZXN0b3JlLmNvbGxlY3Rpb24oJ3N0b2NrcycpO1xuICogY29uc3QgcXVlcnkgPSBjb2xsZWN0aW9uUmVmLndoZXJlKCdwcmljZScsICc+JywgJzAuMDEnKTtcbiAqIGNvbnN0IGZha2VTdG9jayA9IG5ldyBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbjxTdG9jaz4oY29sbGVjdGlvblJlZiwgcXVlcnkpO1xuICpcbiAqIC8vIE5PVEUhOiB0aGUgdXBkYXRlcyBhcmUgcGVyZm9ybWVkIG9uIHRoZSByZWZlcmVuY2Ugbm90IHRoZSBxdWVyeVxuICogYXdhaXQgZmFrZVN0b2NrLmFkZCh7IG5hbWU6ICdGQUtFJywgcHJpY2U6IDAuMDEgfSk7XG4gKlxuICogLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgYXMgc25hcHNob3RzLiBUaGlzIHByb3ZpZGVzIHlvdSBkYXRhIHVwZGF0ZXMgYXMgd2VsbCBhcyBkZWx0YSB1cGRhdGVzLlxuICogZmFrZVN0b2NrLnZhbHVlQ2hhbmdlcygpLnN1YnNjcmliZSh2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xuICovXG5leHBvcnQgY2xhc3MgQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248VCA9IERvY3VtZW50RGF0YT4ge1xuICAvKipcbiAgICogVGhlIGNvbnN0cnVjdG9yIHRha2VzIGluIGEgQ29sbGVjdGlvblJlZmVyZW5jZSBhbmQgUXVlcnkgdG8gcHJvdmlkZSB3cmFwcGVyIG1ldGhvZHNcbiAgICogZm9yIGRhdGEgb3BlcmF0aW9ucyBhbmQgZGF0YSBzdHJlYW1pbmcuXG4gICAqXG4gICAqIE5vdGU6IERhdGEgb3BlcmF0aW9uIG1ldGhvZHMgYXJlIGRvbmUgb24gdGhlIHJlZmVyZW5jZSBub3QgdGhlIHF1ZXJ5LiBUaGlzIG1lYW5zXG4gICAqIHdoZW4geW91IHVwZGF0ZSBkYXRhIGl0IGlzIG5vdCB1cGRhdGluZyBkYXRhIHRvIHRoZSB3aW5kb3cgb2YgeW91ciBxdWVyeSB1bmxlc3NcbiAgICogdGhlIGRhdGEgZml0cyB0aGUgY3JpdGVyaWEgb2YgdGhlIHF1ZXJ5LiBTZWUgdGhlIEFzc29jaWF0ZWRSZWZlbmNlIHR5cGUgZm9yIGRldGFpbHNcbiAgICogb24gdGhpcyBpbXBsaWNhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSByZWY6IENvbGxlY3Rpb25SZWZlcmVuY2U8VD4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBxdWVyeTogUXVlcnk8VD4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBhZnM6IEFuZ3VsYXJGaXJlc3RvcmUpIHsgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gdGhlIGxhdGVzdCBjaGFuZ2UgaW4gdGhlIHN0cmVhbS4gVGhpcyBtZXRob2QgcmV0dXJucyBjaGFuZ2VzXG4gICAqIGFzIHRoZXkgb2NjdXIgYW5kIHRoZXkgYXJlIG5vdCBzb3J0ZWQgYnkgcXVlcnkgb3JkZXIuIFRoaXMgYWxsb3dzIHlvdSB0byBjb25zdHJ1Y3RcbiAgICogeW91ciBvd24gZGF0YSBzdHJ1Y3R1cmUuXG4gICAqL1xuICBzdGF0ZUNoYW5nZXMoZXZlbnRzPzogRG9jdW1lbnRDaGFuZ2VUeXBlW10pOiBPYnNlcnZhYmxlPERvY3VtZW50Q2hhbmdlQWN0aW9uPFQ+W10+IHtcbiAgICBsZXQgc291cmNlID0gZG9jQ2hhbmdlczxUPih0aGlzLnF1ZXJ5LCB0aGlzLmFmcy5zY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyKTtcbiAgICBpZiAoZXZlbnRzICYmIGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2UucGlwZShcbiAgICAgICAgbWFwKGFjdGlvbnMgPT4gYWN0aW9ucy5maWx0ZXIoY2hhbmdlID0+IGV2ZW50cy5pbmRleE9mKGNoYW5nZS50eXBlKSA+IC0xKSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIC8vIFdlIHdhbnQgdG8gZmlsdGVyIG91dCBlbXB0eSBhcnJheXMsIGJ1dCBhbHdheXMgZW1pdCBhdCBmaXJzdCwgc28gdGhlIGRldmVsb3BlciBrbm93c1xuICAgICAgLy8gdGhhdCB0aGUgY29sbGVjdGlvbiBoYXMgYmVlbiByZXNvbHZlOyBldmVuIGlmIGl0J3MgZW1wdHlcbiAgICAgIHN0YXJ0V2l0aDxEb2N1bWVudENoYW5nZUFjdGlvbjxUPltdLCB1bmRlZmluZWQ+KHVuZGVmaW5lZCksXG4gICAgICBwYWlyd2lzZSgpLFxuICAgICAgZmlsdGVyKChbcHJpb3IsIGN1cnJlbnRdKSA9PiBjdXJyZW50Lmxlbmd0aCA+IDAgfHwgIXByaW9yKSxcbiAgICAgIG1hcCgoW3ByaW9yLCBjdXJyZW50XSkgPT4gY3VycmVudCksXG4gICAgICBrZWVwVW5zdGFibGVVbnRpbEZpcnN0XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJlYW0gb2YgY2hhbmdlcyBhcyB0aGV5IG9jY3VyIGl0IHRpbWUuIFRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gc3RhdGVDaGFuZ2VzKClcbiAgICogYnV0IGl0IGNvbGxlY3RzIGVhY2ggZXZlbnQgaW4gYW4gYXJyYXkgb3ZlciB0aW1lLlxuICAgKi9cbiAgYXVkaXRUcmFpbChldmVudHM/OiBEb2N1bWVudENoYW5nZVR5cGVbXSk6IE9ic2VydmFibGU8RG9jdW1lbnRDaGFuZ2VBY3Rpb248VD5bXT4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlQ2hhbmdlcyhldmVudHMpLnBpcGUoc2NhbigoY3VycmVudCwgYWN0aW9uKSA9PiBbLi4uY3VycmVudCwgLi4uYWN0aW9uXSwgW10pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJlYW0gb2Ygc3luY2hyb25pemVkIGNoYW5nZXMuIFRoaXMgbWV0aG9kIGtlZXBzIHRoZSBsb2NhbCBhcnJheSBpbiBzb3J0ZWRcbiAgICogcXVlcnkgb3JkZXIuXG4gICAqL1xuICBzbmFwc2hvdENoYW5nZXMoZXZlbnRzPzogRG9jdW1lbnRDaGFuZ2VUeXBlW10pOiBPYnNlcnZhYmxlPERvY3VtZW50Q2hhbmdlQWN0aW9uPFQ+W10+IHtcbiAgICBjb25zdCB2YWxpZGF0ZWRFdmVudHMgPSB2YWxpZGF0ZUV2ZW50c0FycmF5KGV2ZW50cyk7XG4gICAgY29uc3Qgc2NoZWR1bGVkU29ydGVkQ2hhbmdlcyQgPSBzb3J0ZWRDaGFuZ2VzPFQ+KHRoaXMucXVlcnksIHZhbGlkYXRlZEV2ZW50cywgdGhpcy5hZnMuc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhcik7XG4gICAgcmV0dXJuIHNjaGVkdWxlZFNvcnRlZENoYW5nZXMkLnBpcGUoXG4gICAgICBrZWVwVW5zdGFibGVVbnRpbEZpcnN0XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gYWxsIGRvY3VtZW50cyBpbiB0aGUgY29sbGVjdGlvbiBhbmQgaXRzIHBvc3NpYmxlIHF1ZXJ5IGFzIGFuIE9ic2VydmFibGUuXG4gICAqXG4gICAqIElmIHRoZSBgaWRGaWVsZGAgb3B0aW9uIGlzIHByb3ZpZGVkLCBkb2N1bWVudCBJRHMgYXJlIGluY2x1ZGVkIGFuZCBtYXBwZWQgdG8gdGhlXG4gICAqIHByb3ZpZGVkIGBpZEZpZWxkYCBwcm9wZXJ0eSBuYW1lLlxuICAgKi9cbiAgdmFsdWVDaGFuZ2VzKCk6IE9ic2VydmFibGU8VFtdPjtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnVuaWZpZWQtc2lnbmF0dXJlc1xuICB2YWx1ZUNoYW5nZXMoe30pOiBPYnNlcnZhYmxlPFRbXT47XG4gIHZhbHVlQ2hhbmdlczxLIGV4dGVuZHMgc3RyaW5nPihvcHRpb25zOiB7aWRGaWVsZDogS30pOiBPYnNlcnZhYmxlPChUICYgeyBbVCBpbiBLXTogc3RyaW5nIH0pW10+O1xuICB2YWx1ZUNoYW5nZXM8SyBleHRlbmRzIHN0cmluZz4ob3B0aW9uczoge2lkRmllbGQ/OiBLfSA9IHt9KTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gZnJvbUNvbGxlY3Rpb25SZWY8VD4odGhpcy5xdWVyeSwgdGhpcy5hZnMuc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhcilcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoYWN0aW9ucyA9PiBhY3Rpb25zLnBheWxvYWQuZG9jcy5tYXAoYSA9PiB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaWRGaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uYS5kYXRhKCkgYXMge30sXG4gICAgICAgICAgICAgIC4uLnsgW29wdGlvbnMuaWRGaWVsZF06IGEuaWQgfVxuICAgICAgICAgICAgfSBhcyBUICYgeyBbVCBpbiBLXTogc3RyaW5nIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhLmRhdGEoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKSxcbiAgICAgICAga2VlcFVuc3RhYmxlVW50aWxGaXJzdFxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkgb25jZS5cbiAgICovXG4gIGdldChvcHRpb25zPzogZmlyZWJhc2UuZmlyZXN0b3JlLkdldE9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnJvbSh0aGlzLnF1ZXJ5LmdldChvcHRpb25zKSkucGlwZShcbiAgICAgIG9ic2VydmVJbnNpZGVBbmd1bGFyLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGRhdGEgdG8gYSBjb2xsZWN0aW9uIHJlZmVyZW5jZS5cbiAgICpcbiAgICogTm90ZTogRGF0YSBvcGVyYXRpb24gbWV0aG9kcyBhcmUgZG9uZSBvbiB0aGUgcmVmZXJlbmNlIG5vdCB0aGUgcXVlcnkuIFRoaXMgbWVhbnNcbiAgICogd2hlbiB5b3UgdXBkYXRlIGRhdGEgaXQgaXMgbm90IHVwZGF0aW5nIGRhdGEgdG8gdGhlIHdpbmRvdyBvZiB5b3VyIHF1ZXJ5IHVubGVzc1xuICAgKiB0aGUgZGF0YSBmaXRzIHRoZSBjcml0ZXJpYSBvZiB0aGUgcXVlcnkuXG4gICAqL1xuICBhZGQoZGF0YTogVCk6IFByb21pc2U8RG9jdW1lbnRSZWZlcmVuY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5yZWYuYWRkKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlZmVyZW5jZSB0byBhIHNpbmdsZSBkb2N1bWVudCBpbiBhIGNvbGxlY3Rpb24uXG4gICAqL1xuICBkb2M8VDIgPSBUPihwYXRoPzogc3RyaW5nKTogQW5ndWxhckZpcmVzdG9yZURvY3VtZW50PFQyPiB7XG4gICAgLy8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gc29sdmUgdGhpcyB0eXBlIGlzc3VlXG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQodGhpcy5yZWYuZG9jKHBhdGgpIGFzIGFueSwgdGhpcy5hZnMpO1xuICB9XG59XG4iXX0=